<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Text Image Generator with Highlights</title>

  <!-- Artifakt Element -->
  <link href="https://fonts.googleapis.com/css2?family=Artifakt+Element&display=swap" rel="stylesheet">

  <script src="https://unpkg.com/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <style>
    :root { --panel-bg:#2a2b2d; --panel-fg:#fff; --accent:#10a37f; --dark:#202123; }
    html,body{height:100%; margin:0; font-family:"Artifakt Element",sans-serif; background:#121212; color:#fff;}
    .app { display:flex; flex-direction:column; align-items:center; padding:12px; padding-bottom:220px; min-height:100%; box-sizing:border-box; }

    /* Canvas */
    .image-canvas {
      aspect-ratio:9/16;
      width:100%;
      max-width:480px;
      display:flex; justify-content:center; align-items:center;
      text-align:center; background:#000;
      position:relative; overflow:hidden;
    }
    .editable-text { max-width:85%; word-wrap:break-word; white-space:pre-wrap; color:#ececf1; font-size:15px; line-height:1.4; text-align:left; }

    .bottom-spacer { height:120px; } /* leave room for toolbar + input */

    /* Download top-right */
    .download-container { position:fixed; top:12px; right:12px; z-index:1200; }
    .download-btn, .download-menu button, .toolbar-btn {
      background:var(--accent); color:#fff; padding:10px 16px; border:none; border-radius:8px; cursor:pointer; font-size:14px;
    }
    .download-btn:hover, .download-menu button:hover, .toolbar-btn:hover { background:#0d8c6b; }
    .download-menu {
      position:absolute; top:48px; right:0; background:var(--panel-bg); border-radius:8px; padding:10px; display:none;
      flex-direction:column; gap:8px; color:var(--panel-fg); box-shadow:0 6px 18px rgba(0,0,0,.4); min-width:180px;
    }

    /* Chat input / bottom area */
    .chat-input-bar {
      position:fixed; bottom:0; left:0; right:0;
      display:flex; align-items:flex-end; justify-content:space-between;
      background:var(--dark); padding:10px 12px; border-top:1px solid #444;
      gap:10px; z-index:100; box-shadow:0 -2px 8px rgba(0,0,0,.25);
    }
    .chat-textarea { flex:1; max-height:180px; min-height:48px; resize:none; background:#2d2d2d; color:#fff; border:none; border-radius:16px; padding:10px 14px; font-size:15px; outline:none; }

    /* Toolbar (horizontal) */
    .settings-toolbar {
      position:fixed; bottom:72px; left:0; right:0;
      display:flex; overflow-x:auto; align-items:center;
      background:#1e1f21; padding:8px 10px; gap:8px; z-index:200;
      box-shadow:0 -2px 8px rgba(0,0,0,.4);
    }
    .settings-toolbar .toolbar-btn {
      background:#2d2d2d; padding:8px 12px; border-radius:10px; font-size:13px;
    }
    .settings-toolbar .toolbar-btn:hover { background:#3a3b3c; }
    /* allow keyboard focus outlines */
    .settings-toolbar .toolbar-btn:focus { outline:2px solid rgba(255,255,255,0.08); }

    /* Panels */
    .settings-panel {
      position:fixed; bottom:118px; left:10px; right:10px; background:var(--panel-bg);
      color:var(--panel-fg); border-radius:16px; padding:14px; box-shadow:0 6px 18px rgba(0,0,0,.5);
      max-height:48vh; overflow:auto; display:none; z-index:300; transition:all .22s ease;
    }
    .settings-panel.open { display:block; }

    .settings-panel label, .settings-panel strong { font-size:14px; margin-bottom:6px; display:flex; align-items:center; gap:8px; }
    .settings-panel input[type="color"], .settings-panel select, .settings-panel input[type="file"], .settings-panel input[type="range"] { margin-top:6px; width:100%; }

    .slider-row { display:flex; align-items:center; gap:8px; margin-bottom:10px; }
    .slider-value { font-size:13px; color:#ddd; min-width:44px; text-align:right; }

    .highlight-section { border-top:1px solid rgba(255,255,255,0.12); padding-top:8px; margin-top:8px; }
    .highlight-row { display:flex; align-items:center; gap:8px; margin-bottom:6px; }
    .add-word-input { width:100%; padding:8px; border-radius:6px; border:none; outline:none; background:#3a3b3c; color:#fff; }

    /* small screens */
    @media (max-width:600px) {
      .settings-toolbar { padding:8px; }
      .settings-panel { left:8px; right:8px; bottom:120px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div id="canvas" class="image-canvas" aria-label="preview canvas">
      <div id="editable-text" class="editable-text" contenteditable="false"></div>
      <img id="overlay" style="display:none; position:absolute; cursor:grab; touch-action:none; transform-origin: top left;" draggable="false" />
    </div>

    <div class="bottom-spacer"></div>
  </div>

  <!-- Download -->
  <div class="download-container">
    <button id="downloadBtn" class="download-btn">Download</button>
    <div id="downloadMenu" class="download-menu" aria-hidden="true">
      <button data-scale="1" data-quality="low">Low Quality</button>
      <button data-scale="2" data-quality="medium">Medium Quality</button>
      <button data-scale="4" data-quality="high">High Quality</button>
    </div>
  </div>

  <!-- Settings toolbar (buttons open panels) -->
  <div class="settings-toolbar" role="toolbar" aria-label="settings toolbar">
    <button class="toolbar-btn" data-panel="fontColorPanel">Font Color</button>
    <button class="toolbar-btn" data-panel="bgPanel">Background</button>
    <button class="toolbar-btn" data-panel="fontSizePanel">Text Size</button>
    <button class="toolbar-btn" data-panel="lineHeightPanel">Line Spacing</button>
    <button class="toolbar-btn" data-panel="alignPanel">Alignment</button>
    <button class="toolbar-btn" data-panel="overlayPanel">Overlay</button>
    <button class="toolbar-btn" data-panel="fontUploadPanel">Font Upload</button>
    <button class="toolbar-btn" data-panel="highlightPanel">Highlights</button>
  </div>

  <!-- Panels (one per button) -->
  <div id="fontColorPanel" class="settings-panel" aria-hidden="true">
    <label>Font Color: <input id="fontColor" type="color" value="#ececf1" /></label>
  </div>

  <div id="bgPanel" class="settings-panel" aria-hidden="true">
    <label>Background: <input id="bgColor" type="color" value="#000000" /></label>
    <label>Background Image: <input id="bgImage" type="file" accept="image/*" /></label>
  </div>

  <div id="fontSizePanel" class="settings-panel" aria-hidden="true">
    <div class="slider-row">
      <label style="flex:1">Text Size:
        <input id="fontSize" type="range" min="10" max="100" value="15" />
      </label>
      <div id="fontSizeVal" class="slider-value">15px</div>
    </div>
  </div>

  <div id="lineHeightPanel" class="settings-panel" aria-hidden="true">
    <div class="slider-row">
      <label style="flex:1">Line Spacing:
        <input id="lineHeight" type="range" min="1" max="3" step="0.1" value="1.4" />
      </label>
      <div id="lineHeightVal" class="slider-value">1.4</div>
    </div>
  </div>

  <div id="alignPanel" class="settings-panel" aria-hidden="true">
    <label>Alignment:
      <select id="textAlign">
        <option value="left">Left</option>
        <option value="center">Center</option>
        <option value="right">Right</option>
      </select>
    </label>
  </div>

  <div id="overlayPanel" class="settings-panel" aria-hidden="true">
    <label>Upload Overlay Image: <input id="overlayUpload" type="file" accept="image/*" /></label>
    <div class="slider-row">
      <label style="flex:1">Overlay Size:
        <input id="overlaySize" type="range" min="50" max="1000" value="200" />
      </label>
      <div id="overlaySizeVal" class="slider-value">200px</div>
    </div>
    <small style="color:#bbb;">Tip: pinch to zoom (two fingers) on touch devices; drag to reposition.</small>
  </div>

  <div id="fontUploadPanel" class="settings-panel" aria-hidden="true">
    <label>Upload Font from Device: <input id="fontUpload" type="file" accept=".ttf,.otf,.woff,.woff2" /></label>
  </div>

  <div id="highlightPanel" class="settings-panel" aria-hidden="true">
    <div class="highlight-section" aria-live="polite">
      <strong>Highlight Words</strong>
      <div style="display:flex;align-items:center;gap:8px;"><input id="selectAllWords" type="checkbox" /> <label for="selectAllWords" style="cursor:pointer;">Select All / Unselect All</label></div>
      <div id="highlightWordsContainer" aria-label="highlight words list"></div>
      <input id="addWordInput" class="add-word-input" placeholder="Add custom word and press Enter" />
    </div>
  </div>

  <!-- Chat input -->
  <div class="chat-input-bar" role="region" aria-label="controls">
    <textarea id="textInput" class="chat-textarea" placeholder="Type your text here"></textarea>
  </div>

  <script>
    /***********************
      Elements & state
    ***********************/
    const canvas = document.getElementById('canvas');
    const textEl = document.getElementById('editable-text');
    const textInput = document.getElementById('textInput');

    const overlay = document.getElementById('overlay');
    const overlayUpload = document.getElementById('overlayUpload');
    const overlaySizeInput = document.getElementById('overlaySize');
    const overlaySizeVal = document.getElementById('overlaySizeVal');

    const fontColorInput = document.getElementById('fontColor');
    const bgColorInput = document.getElementById('bgColor');
    const bgImageInput = document.getElementById('bgImage');
    const fontSizeInput = document.getElementById('fontSize');
    const fontSizeVal = document.getElementById('fontSizeVal');
    const lineHeightInput = document.getElementById('lineHeight');
    const lineHeightVal = document.getElementById('lineHeightVal');
    const textAlignInput = document.getElementById('textAlign');

    const fontUpload = document.getElementById('fontUpload');

    const highlightContainer = document.getElementById('highlightWordsContainer');
    const addWordInput = document.getElementById('addWordInput');
    const selectAllCheckbox = document.getElementById('selectAllWords');

    const downloadBtn = document.getElementById('downloadBtn');
    const downloadMenu = document.getElementById('downloadMenu');

    const toolbarButtons = document.querySelectorAll('.settings-toolbar .toolbar-btn');
    const panels = document.querySelectorAll('.settings-panel');

    // geometry & interaction state
    let overlayX = 40, overlayY = 40;
    let dragging = false, startX = 0, startY = 0, startOverlayX = 0, startOverlayY = 0;
    let isPinching = false, startDistance = 0, startScale = 1, currentScale = 1;

    // highlight words state
    let detectedWords = [], customWords = [], highlightedWords = {};

    // stopWords (kept from your original list)
    const stopWords = ["the","is","a","an","and","or","in","on","at","of","for","to","with","by","you","your","this","that","it","as","be","are","was","were","from","into","but","if","so","about","can","not","i","me","my","myself","we","our","ours","ourselves","he","him","his","himself","she","her","hers","herself","they","them","their","theirs","themselves","what","which","who","whom","these","those","am","been","being","have","has","had","having","do","does","did","doing","because","until","while","against","between","through","during","before","after","above","below","up","down","out","off","over","under","again","further","then","once","here","there","when","where","why","all","any","both","each","few","more","most","other","some","such","no","nor","only","own","same","than","too","very"];

    /***********************
      Utilities
    ***********************/
    function escapeRegex(s){ return s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'); }

    /***********************
      Highlighting logic
    ***********************/
    function updateHighlightedText(){
      // Build result by replacing highlighted words with bold spans
      let txt = textInput.value || "";
      const allOrder = Array.from(new Set([...detectedWords, ...customWords]));
      allOrder.forEach(w => {
        if (highlightedWords[w]) {
          const regex = new RegExp("\\b(" + escapeRegex(w) + ")\\b", "gi");
          txt = txt.replace(regex, '<span style="font-weight:bold;">$1</span>');
        }
      });
      textEl.innerHTML = txt.replace(/\n/g, "<br/>");
    }

    function updateDetectedWords(){
      const content = (textInput.value || "").toLowerCase().replace(/[.,!?;:()"]/g,"");
      const arr = content.split(/\s+/).filter(w => w && !stopWords.includes(w));
      const freq = {};
      arr.forEach(w => freq[w] = (freq[w]||0)+1);
      detectedWords = Object.keys(freq).sort((a,b)=> (freq[b]-freq[a]) || (b.length - a.length)).slice(0,8);
      // default new ones to true if not set
      detectedWords.forEach(w => { if (!(w in highlightedWords)) highlightedWords[w] = true; });
      renderHighlightWords();
    }

    function renderHighlightWords(){
      highlightContainer.innerHTML = "";
      const all = Array.from(new Set([...detectedWords, ...customWords]));
      all.forEach((word, idx) => {
        const id = 'cb_'+idx+'_'+word.replace(/[^a-z0-9]/gi,'_')+'_'+Math.random().toString(36).slice(2,7);
        const row = document.createElement('div');
        row.className = 'highlight-row';

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.id = id;
        cb.checked = !!highlightedWords[word];
        cb.addEventListener('change', () => {
          highlightedWords[word] = cb.checked;
          updateHighlightedText();
          selectAllCheckbox.checked = Array.from(new Set([...detectedWords, ...customWords])).every(w => highlightedWords[w]);
        });

        const lbl = document.createElement('label');
        lbl.htmlFor = id;
        lbl.textContent = word;

        row.appendChild(cb);
        row.appendChild(lbl);
        highlightContainer.appendChild(row);
      });

      updateHighlightedText();
      selectAllCheckbox.checked = Array.from(new Set([...detectedWords, ...customWords])).every(w => highlightedWords[w]);
    }

    /***********************
      Toolbar panel behaviour
    ***********************/
    toolbarButtons.forEach(btn => {
      btn.addEventListener('click', (ev) => {
        const panelId = btn.dataset.panel;
        const target = document.getElementById(panelId);
        const isOpen = target.classList.contains('open');
        panels.forEach(p => { p.classList.remove('open'); p.setAttribute('aria-hidden','true'); });
        if (!isOpen) { target.classList.add('open'); target.setAttribute('aria-hidden','false'); }
        ev.stopPropagation();
      });
    });

    // Close panels on outside click/tap
    document.addEventListener('pointerdown', (e) => {
      if (![...panels].some(p => p.contains(e.target)) && ![...toolbarButtons].some(b => b.contains(e.target))) {
        panels.forEach(p => { p.classList.remove('open'); p.setAttribute('aria-hidden','true'); });
      }
    });

    /***********************
      Event bindings (text input -> detection)
    ***********************/
    // sync text input into preview
    textInput.addEventListener('input', () => {
      updateDetectedWords();
      updateHighlightedText();
    });

    // add custom word (Enter)
    addWordInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        const w = e.target.value.toLowerCase().trim();
        if (w && !customWords.includes(w)) {
          customWords.push(w);
          highlightedWords[w] = true;
          renderHighlightWords();
          updateHighlightedText();
        }
        e.target.value = '';
      }
    });

    selectAllCheckbox.addEventListener('change', () => {
      const all = Array.from(new Set([...detectedWords, ...customWords]));
      all.forEach(w => highlightedWords[w] = selectAllCheckbox.checked);
      renderHighlightWords();
    });

    /***********************
      Colors, alignment, sliders
    ***********************/
    fontColorInput.addEventListener('input', e => textEl.style.color = e.target.value);
    bgColorInput.addEventListener('input', e => { canvas.style.background = e.target.value; canvas.style.backgroundImage=''; });

    bgImageInput.addEventListener('change', e => {
      const f = e.target.files[0]; if (!f) return;
      const r = new FileReader();
      r.onload = ev => { canvas.style.background = `url(${ev.target.result}) center/cover no-repeat`; };
      r.readAsDataURL(f);
    });

    fontSizeInput.addEventListener('input', e => {
      textEl.style.fontSize = e.target.value + 'px';
      fontSizeVal.textContent = e.target.value + 'px';
    });
    fontSizeVal.textContent = fontSizeInput.value + 'px';

    lineHeightInput.addEventListener('input', e => {
      textEl.style.lineHeight = e.target.value;
      lineHeightVal.textContent = e.target.value;
    });
    lineHeightVal.textContent = lineHeightInput.value;

    textAlignInput.addEventListener('change', e => textEl.style.textAlign = e.target.value);

    /***********************
      Overlay upload + behavior
    ***********************/
    // When overlay image loads, set base size and sync slider
    overlay.addEventListener('load', () => {
      // set a base width (use naturalWidth, but don't continuously change it later)
      overlay.style.width = overlay.naturalWidth + 'px';
      overlay.style.height = 'auto';
      overlay.style.left = overlayX + 'px';
      overlay.style.top = overlayY + 'px';
      currentScale = 1;
      overlay.style.transform = `scale(${currentScale})`;
      overlaySizeInput.value = Math.round(overlay.naturalWidth * currentScale);
      overlaySizeVal.textContent = overlaySizeInput.value + 'px';
      overlay.style.display = 'block';
    });

    overlayUpload.addEventListener('change', e => {
      const f = e.target.files[0];
      if (!f) return;
      const r = new FileReader();
      r.onload = ev => {
        overlay.src = ev.target.result;
      };
      r.readAsDataURL(f);
    });

    // Slider: adjusts scale (not width attribute)
    overlaySizeInput.addEventListener('input', e => {
      if (!overlay.naturalWidth) return;
      currentScale = overlaySizeInput.value / overlay.naturalWidth;
      currentScale = Math.max(0.1, Math.min(10, currentScale));
      overlay.style.transform = `scale(${currentScale})`;
      overlaySizeVal.textContent = Math.round(overlay.naturalWidth * currentScale) + 'px';
    });

    /***********************
      Dragging (pointer events) & pointer/touch coordination
    ***********************/
    function pointerDownHandler(e) {
      // don't start a drag while a pinch is in progress
      if (isPinching) return;
      // only primary pointer starts drag
      if (e.isPrimary === false) return;
      dragging = true;
      startX = e.clientX;
      startY = e.clientY;
      startOverlayX = overlayX;
      startOverlayY = overlayY;
      try { overlay.setPointerCapture(e.pointerId); } catch(_) {}
      overlay.style.cursor = 'grabbing';
    }
    function pointerMoveHandler(e) {
      if (!dragging) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      overlayX = startOverlayX + dx;
      overlayY = startOverlayY + dy;
      overlay.style.left = overlayX + 'px';
      overlay.style.top = overlayY + 'px';
    }
    function pointerUpHandler(e) {
      dragging = false;
      try { overlay.releasePointerCapture(e.pointerId); } catch(_) {}
      overlay.style.cursor = 'grab';
    }

    overlay.addEventListener('pointerdown', pointerDownHandler);
    window.addEventListener('pointermove', pointerMoveHandler);
    window.addEventListener('pointerup', pointerUpHandler);

    /***********************
      Pinch-to-zoom (touch events) - ONLY uses transform:scale()
    ***********************/
    overlay.addEventListener('touchstart', e => {
      if (e.touches.length === 2) {
        e.preventDefault();
        isPinching = true;
        // compute initial distance
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        startDistance = Math.hypot(dx, dy);
        startScale = currentScale;
      }
    }, { passive: false });

    overlay.addEventListener('touchmove', e => {
      if (e.touches.length === 2 && isPinching) {
        e.preventDefault();
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const newDist = Math.hypot(dx, dy);
        const scaleChange = newDist / startDistance;
        currentScale = Math.max(0.1, Math.min(10, startScale * scaleChange));
        overlay.style.transform = `scale(${currentScale})`;
        if (overlay.naturalWidth) {
          overlaySizeInput.value = Math.round(overlay.naturalWidth * currentScale);
          overlaySizeVal.textContent = overlaySizeInput.value + 'px';
        }
      }
    }, { passive: false });

    overlay.addEventListener('touchend', e => {
      // if fewer than 2 touches remain, end pinch mode after small delay
      if ((e.touches && e.touches.length) < 2) {
        setTimeout(()=> { isPinching = false; }, 10);
      }
    }, { passive: false });

    /***********************
      Font upload (FontFace API)
    ***********************/
    fontUpload.addEventListener('change', e => {
      const f = e.target.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = ev => {
        const blob = new Blob([ev.target.result]);
        const url = URL.createObjectURL(blob);
        const face = new FontFace(f.name, `url(${url})`);
        face.load().then(loaded => {
          document.fonts.add(loaded);
          textEl.style.fontFamily = `"${f.name}", "Artifakt Element", sans-serif`;
        }).catch(err => console.error('font load failed', err));
      };
      // read as arrayBuffer for FontFace
      reader.readAsArrayBuffer(f);
    });

    /***********************
      Download menu & html2canvas
    ***********************/
    downloadBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      downloadMenu.style.display = downloadMenu.style.display === 'flex' ? 'none' : 'flex';
    });
    downloadMenu.querySelectorAll('button').forEach(btn => {
      btn.addEventListener('click', () => {
        const scale = parseInt(btn.dataset.scale || '2', 10);
        html2canvas(canvas, { scale }).then(cnv => {
          const a = document.createElement('a');
          a.download = `image-${btn.dataset.quality || 'medium'}.png`;
          a.href = cnv.toDataURL('image/png');
          a.click();
        }).catch(err => console.error(err));
        downloadMenu.style.display = 'none';
      });
    });

    // hide menus/panels with outside click
    document.addEventListener('click', (e) => {
      if (!downloadMenu.contains(e.target) && e.target !== downloadBtn) downloadMenu.style.display = 'none';
      if (![...panels].some(p => p.contains(e.target)) && ![...toolbarButtons].some(b => b.contains(e.target))) {
        panels.forEach(p => { p.classList.remove('open'); p.setAttribute('aria-hidden','true'); });
      }
    });

    // Escape key closes all
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        downloadMenu.style.display = 'none';
        panels.forEach(p => { p.classList.remove('open'); p.setAttribute('aria-hidden','true'); });
      }
    });

    /***********************
      Overlay pointer capture cleanup when pointercancel
    ***********************/
    overlay.addEventListener('pointercancel', () => { dragging = false; try { overlay.releasePointerCapture(); } catch(_){}; overlay.style.cursor='grab'; });

    /***********************
      Init / detection
    ***********************/
    // initialize values & detection
    (function init() {
      // apply initial styles from inputs
      textEl.style.color = fontColorInput.value;
      canvas.style.background = bgColorInput.value;
      textEl.style.fontSize = fontSizeInput.value + 'px';
      textEl.style.lineHeight = lineHeightInput.value;
      textEl.style.textAlign = textAlignInput.value;
      overlay.style.transform = `scale(${currentScale})`;

      // initial detection & preview
      if (typeof textInput.value === 'undefined' || textInput.value.trim() === '') {
        // try to use editable preview if it's prefilled
        textInput.value = textEl.innerText || '';
      }
      updateDetectedWords();
      updateHighlightedText();
    })();

    /***********************
      Helper: keep highlight words in sync if user pastes large text directly into preview
    ***********************/
    // If user pastes into preview (contenteditable was false earlier, but keep safe)
    textEl.addEventListener('input', () => {
      // copy contenteditable changes back to the textInput so logic stays consistent
      textInput.value = textEl.innerText;
      updateDetectedWords();
      updateHighlightedText();
    });
  </script>
</body>
</html>
